curl -XPOST https://clearnet-sandbox.yellow.com/faucet/requestTokens \
  -H "Content-Type: application/json" \
  -d '{"userAddress":"0xa4200162309D1F65CC1eadDe023ba42Ccfb6eD16"}'


// import {
//   NitroliteClient,
//   WalletStateSigner,
//   createECDSAMessageSigner,
//   createEIP712AuthMessageSigner,
//   createAuthRequestMessage,
//   createAuthVerifyMessageFromChallenge,
//   createGetLedgerBalancesMessage,
//   createGetChannelsMessage,
// } from '@erc7824/nitrolite';

// import { createPublicClient, http, type WalletClient } from 'viem';
// import { sepolia } from 'viem/chains';
// import { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';

// import { connectClearnode } from './connect';
// import { setupWalletClient } from './wallet';
// import { parseMessage } from './messages';

// import {
//   openChannel as sessionOpenChannel,
//   resizeChannel as sessionResizeChannel,
//   closeChannel as sessionCloseChannel,
// } from './session';

// import { sendPayment } from './payments';
// import 'dotenv/config';

// export class YellowClient {
//   ws: WebSocket;
//   account: string;
//   walletClient: WalletClient;
//   publicClient: any;
//   client: NitroliteClient;

//   sessionSigner: any;
//   sessionAddress: string;

//   isAuthenticated = false;

//   constructor(ws: WebSocket, account: string, walletClient: any, publicClient: any) {
//     this.ws = ws;
//     this.account = account;
//     this.walletClient = walletClient;
//     this.publicClient = publicClient;

//     this.client = new NitroliteClient({
//       publicClient,
//       walletClient,
//       stateSigner: new WalletStateSigner(walletClient),
//       addresses: {
//         custody: '0x019B65A265EB3363822f2752141b3dF16131b262',
//         adjudicator: '0x7c7ccbc98469190849BCC6c926307794fDfB11F2',
//       },
//       chainId: sepolia.id,
//       challengeDuration: 3600n,
//     });

//     const sessionPrivateKey = generatePrivateKey();
//     const sessionAccount = privateKeyToAccount(sessionPrivateKey);

//     this.sessionAddress = sessionAccount.address;
//     this.sessionSigner = createECDSAMessageSigner(sessionPrivateKey);

//     console.log(`[Yellow] Initialized for: ${this.account}`);

//     /* ======================================================
//    ðŸ”¥ GLOBAL WS LISTENER (AUTO NITRO FLOW HANDLER)
//    REQUIRED FOR CHANNEL SETTLEMENT
// ====================================================== */

// this.ws.addEventListener('message', async (event) => {
//   const msg = parseMessage(event);
//   if (!msg) return;

//   console.log('ðŸ“¥ WS EVENT â†’', msg.type);

//   /* -----------------------------
//      Channel prepared â†’ create L1
//   ----------------------------- */
//   if (msg.type === 'create_channel') {
//     console.log('ðŸŸ¡ Channel prepared by node â†’ creating on-chain...');

//     const { channel, state, server_signature } = msg.payload;

//     const unsignedInitialState = {
//       intent: state.intent,
//       version: BigInt(state.version),
//       data: state.state_data,
//       allocations: state.allocations.map((a: any) => ({
//         destination: a.destination,
//         token: a.token,
//         amount: BigInt(a.amount),
//       })),
//     };

//     const tx = await this.client.createChannel({
//       channel,
//       unsignedInitialState,
//       serverSignature: server_signature,
//     });

//     console.log('âœ… Channel created on-chain:', tx);
//   }

//   /* -----------------------------
//      Resize confirmed
//   ----------------------------- */
//   if (msg.type === 'resize_channel') {
//     console.log('âœ… Channel funded successfully');
//   }

//   /* -----------------------------
//      ðŸ”¥ MOST IMPORTANT PART
//      Auto finalize close
//   ----------------------------- */
//   if (msg.type === 'close_channel') {
//     console.log('ðŸŸ¡ Node signed close â†’ finalizing on-chain...');

//     const finalState = {
//       intent: msg.payload.state.intent,
//       version: BigInt(msg.payload.state.version),
//       data: msg.payload.state.state_data,
//       allocations: msg.payload.state.allocations.map((a: any) => ({
//         destination: a.destination,
//         token: a.token,
//         amount: BigInt(a.amount),
//       })),
//       channelId: msg.payload.channel_id,
//       serverSignature: msg.payload.server_signature,
//     };

//     await this.finalizeClose(finalState);

//     console.log('ðŸŽ‰ Funds released back to wallet');
//   }
// });

//   }

//   /* ======================================================
//      AUTH
//   ====================================================== */

//   async authenticate() {
//     return new Promise<void>(async (resolve) => {
//       console.log('ðŸŸ¡ [STEP 0] Authenticating...');

//       const authParams = {
//         session_key: this.sessionAddress as `0x${string}`,
//         allowances: [{ asset: 'ytest.usd', amount: '1000000000' }],
//         expires_at: BigInt(Math.floor(Date.now() / 1000) + 3600),
//         scope: 'test.app',
//       };

//       const authRequestMsg = await createAuthRequestMessage({
//         address: this.account as `0x${string}`,
//         application: 'Test app',
//         ...authParams,
//       });

//       const handler = async (event: MessageEvent) => {
//         const msg = parseMessage(event);
//         if (!msg) return;

//         if (msg.type === 'auth_challenge') {
//           const signer = createEIP712AuthMessageSigner(this.walletClient, authParams, { name: 'Test app' });
//           const verifyMsg = await createAuthVerifyMessageFromChallenge(signer, msg.payload.challenge_message);
//           this.ws.send(verifyMsg);
//         }

//         if (msg.type === 'auth_verify') {
//           console.log('âœ… Authenticated');
//           this.isAuthenticated = true;
//           this.ws.removeEventListener('message', handler);
//           resolve();
//         }
//       };

//       this.ws.addEventListener('message', handler);
      // if (this.ws.readyState === WebSocket.OPEN) {
      //   console.log('[Yellow] Sending auth request');
      //   this.ws.send(authRequestMsg);
      // } else {
      //   this.ws.onopen = () => this.ws.send(authRequestMsg);
      // }
//     });
//   }

//   /* ======================================================
//      BALANCES
//   ====================================================== */

//   async getBalance(asset: string = 'ytest.usd'): Promise<string> {
//     console.log('ðŸŸ¡ Fetching off-chain balance...');

//     return new Promise((resolve) => {
//       const handler = (event: MessageEvent) => {
//         const msg = parseMessage(event);
//         if (msg?.type === 'get_ledger_balances') {
//           const bal = msg.payload.ledger_balances.find((b: any) => b.asset === asset);
//           this.ws.removeEventListener('message', handler);
//           console.log('âœ… Ledger balance:', bal?.amount || '0');
//           resolve(bal?.amount || '0');
//         }
//       };

//       this.ws.addEventListener('message', handler);
//       createGetLedgerBalancesMessage(this.sessionSigner, this.account as `0x${string}`)
//         .then(m => this.ws.send(m));
//     });
//   }

//   /* ======================================================
//      ðŸ”¥ NEW â€” NITRO REQUIRED METHODS
//   ====================================================== */

//   async deposit(token: `0x${string}`, amount: bigint) {
//     console.log('ðŸŸ¡ [STEP 1] Depositing to custody...');
//     const txHash = await this.client.deposit(token, amount);
//     console.log('âœ… Deposit tx:', txHash);
//     return txHash;
//   }

//   async getCustodyBalance(token: `0x${string}`): Promise<bigint> {
//     console.log('ðŸŸ¡ Checking custody balance...');

//     const result = await this.publicClient.readContract({
//       address: this.client.addresses.custody,
//       abi: [{
//         type: 'function',
//         name: 'getAccountsBalances',
//         inputs: [
//           { name: 'users', type: 'address[]' },
//           { name: 'tokens', type: 'address[]' }
//         ],
//         outputs: [{ type: 'uint256[]' }],
//         stateMutability: 'view'
//       }] as const,
//       functionName: 'getAccountsBalances',
//       args: [[this.account], [token]],
//     }) as bigint[];

//     console.log('âœ… Custody balance:', result[0].toString());
//     return result[0];
//   }

//   async requestChannels() {
//     console.log('ðŸŸ¡ [STEP 2] Requesting open channels...');
//     const msg = await createGetChannelsMessage(this.sessionSigner, this.account as `0x${string}`);
//     this.ws.send(msg);
//   }

//   async finalizeClose(finalState: any) {
//     console.log('ðŸŸ¡ [STEP 6] Closing channel on-chain...');
//     const txHash = await this.client.closeChannel({ finalState, stateData: '0x' });
//     console.log('âœ… Channel closed on-chain:', txHash);
//     return txHash;
//   }

//   /* ======================================================
//      EXISTING WRAPPERS (UNCHANGED)
//   ====================================================== */

//   async openChannel(token: string) {
//     console.log('ðŸŸ¡ [STEP 3] Creating channel...');
//     return sessionOpenChannel(this.ws, this.sessionSigner, 11155111, token);
//   }

//   async resizeChannel(channelId: string, amount: bigint, destination: string) {
//     console.log('ðŸŸ¡ [STEP 4] Funding channel...');
//     return sessionResizeChannel(this.ws, this.sessionSigner, channelId, amount, destination);
//   }

//   async closeChannel(channelId: string) {
//     console.log('ðŸŸ¡ [STEP 5] Requesting close...');
//     return sessionCloseChannel(this.ws, this.sessionSigner, channelId, this.account);
//   }

//   async pay(amount: number, recipient: string) {
//     console.log('ðŸŸ¡ Sending payment...');
//     return sendPayment(this.ws, this.sessionSigner, amount.toString(), recipient);
//   }
// }

// /* ======================================================
//    INIT
// ====================================================== */

// export async function initYellow() {
//   const { walletClient, account } = await setupWalletClient();
//   const ws = connectClearnode('wss://clearnet-sandbox.yellow.com/ws');

//   const publicClient = createPublicClient({
//     chain: sepolia,
//     transport: http(process.env.ALCHEMY_RPC_URL),
//   });

//   const client = new YellowClient(ws, account, walletClient, publicClient);

//   await client.authenticate();
//   await client.getBalance();

//   return client;
// }




